/**
 * Service Worker for DeFiTuna PnL Viewer
 * Handles background data synchronization.
 */

// --- Workbox Precache --- 
// These imports rely on next-pwa injecting the necessary Workbox libraries
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

// Inject the manifest generated by next-pwa/Workbox
// This line is crucial for InjectManifest strategy
precacheAndRoute(self.__WB_MANIFEST || []);

// Example: Optional runtime caching (if needed, customize strategy)
// registerRoute(
//   ({request}) => request.destination === 'image',
//   new StaleWhileRevalidate({
//     cacheName: 'images',
//   })
// );

// --- Imports ---
// Import necessary utilities from the /src directory
import { initializeDB, savePositionSnapshot, STORE_NAMES } from '@/utils/indexedDB';
import { fetchWalletPnL } from '@/utils/pnlUtils'; // Assuming fetchWalletPnL handles decoding and address adding now

// --- Configuration ---
const SYNC_INTERVAL = 30 * 1000; // Default sync interval (30 seconds)

// --- Background Sync Logic ---
let syncTimer = null;
let currentWallets = []; // Keep track of wallets to sync
let syncIntervalId = SYNC_INTERVAL; // Use default initially

const fetchAllPositions = async () => {
  console.log('[SW] Running background sync for wallets:', currentWallets);
  if (currentWallets.length === 0) {
    console.log('[SW] No wallets to sync. Skipping fetch.');
    return;
  }

  try {
    const db = await initializeDB();
    if (!db) {
      console.error('[SW] Failed to initialize DB for sync.');
      return;
    }

    // Fetch data for all wallets concurrently
    const results = await Promise.all(
      currentWallets.map(wallet => fetchWalletPnL(wallet)) // Use imported fetchWalletPnL
    );

    // Filter out null/error results and flatten positions
    const allPositions = results
                            .filter(data => data && !data.error && Array.isArray(data.positions)) // Check for error property
                            .flatMap(data => data.positions);

    if (allPositions.length > 0) {
      console.log(`[SW] Saving snapshot for ${allPositions.length} total positions.`);
      // Use imported savePositionSnapshot
      const success = await savePositionSnapshot(db, allPositions); 
      if (!success) {
        console.error('[SW] Failed to save combined position snapshot.');
      }
    } else {
      console.log('[SW] No valid positions found across all wallets to save.');
    }

  } catch (error) {
    console.error('[SW] Error during fetchAllPositions:', error);
  }
};

const startSyncTimer = () => {
  console.log(`[SW] Starting background sync timer with interval: ${syncIntervalId / 1000}s`);
  // Run immediately first time
  fetchAllPositions(); 
  syncTimer = setInterval(fetchAllPositions, syncIntervalId);
};

const stopSyncTimer = () => {
  if (syncTimer) {
    console.log('[SW] Stopping background sync timer.');
    clearInterval(syncTimer);
    syncTimer = null;
  }
};

// --- Service Worker Event Listeners ---

self.addEventListener('install', (event) => {
  console.log('[SW] Installed');
  event.waitUntil(self.skipWaiting());
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activated');
  event.waitUntil(self.clients.claim());
  // Initialize DB on activation to ensure stores are created
  event.waitUntil(initializeDB().then(() => {
      console.log('[SW] DB initialized on activation.');
  }));
});

self.addEventListener('message', (event) => {
  console.log('[SW] Message received:', event.data);
  if (!event.data) return;

  switch (event.data.type) {
    case 'SET_WALLETS':
      currentWallets = event.data.wallets || [];
      console.log('[SW] Updated wallets for sync:', currentWallets);
      break;
    case 'START_SYNC':
      console.log('[SW] Received START_SYNC message.');
      if (currentWallets.length > 0) {
        startSyncTimer();
      } else {
        console.log('[SW] Cannot start sync: No wallets provided yet.');
      }
      break;
    case 'STOP_SYNC':
      console.log('[SW] Received STOP_SYNC message.');
      stopSyncTimer();
      break;
    case 'SET_INTERVAL':
      const newInterval = Number(event.data.interval) * 1000;
      if (!isNaN(newInterval) && newInterval > 0) {
        syncIntervalId = newInterval;
        console.log(`[SW] Sync interval updated to: ${syncIntervalId / 1000}s`);
        if (syncTimer) {
          startSyncTimer(); // Restart timer with new interval
        }
      } else {
        console.warn(`[SW] Received invalid interval: ${event.data.interval}`);
      }
      break;
    default:
      console.warn('[SW] Received unknown message type:', event.data.type);
  }
});

// Note: fetch listener for caching is omitted as per the plan. 