/**
 * Service Worker for DeFiTuna PnL Viewer
 * Handles background data synchronization.
 */

// --- Workbox Precache --- 
// These imports rely on next-pwa injecting the necessary Workbox libraries
import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

// Inject the manifest generated by next-pwa/Workbox
// This line is crucial for InjectManifest strategy
precacheAndRoute(self.__WB_MANIFEST || []);

// Example: Optional runtime caching (if needed, customize strategy)
// registerRoute(
//   ({request}) => request.destination === 'image',
//   new StaleWhileRevalidate({
//     cacheName: 'images',
//   })
// );

// --- Imports ---
// Import necessary utilities from the /src directory
import { initializeDB, savePositionSnapshot, getData, STORE_NAMES } from '@/utils/indexedDB';
import { fetchWalletPnL } from '@/utils/pnlUtils';
import { REFRESH_INTERVALS } from '@/utils/constants';

// --- Configuration ---
// How often the timer should attempt to sync data (scheduler)
const DEFAULT_SYNC_INTERVAL = REFRESH_INTERVALS.DEFAULT * REFRESH_INTERVALS.SECONDS;
// Minimum time that must pass between actual API calls (throttling)
const MIN_FETCH_INTERVAL = REFRESH_INTERVALS.getMinimum() * REFRESH_INTERVALS.SECONDS;
// More generous buffer (200ms) to avoid throttling requests that are very close to the minimum interval
const THROTTLE_TOLERANCE = 200;

// --- Background Sync Logic ---
let syncTimer = null;
let currentWallets = []; // Keep track of wallets to sync
let syncIntervalId = DEFAULT_SYNC_INTERVAL; // Use default initially
let lastFetchTime = 0; // Track when we last performed a fetch
let isTimerRunning = false; // Track if a timer is already running
let syncInProgress = false; // Track if a fetch operation is currently running

const fetchAllPositions = async () => {
  syncInProgress = true;
  let fetchOutcome = { success: false, positionsFound: 0, timestamp: Date.now(), results: null }; 

  try {
    // Skip if no wallets configured
    if (currentWallets.length === 0) {
      console.log('[SW] No wallets to sync. Skipping fetch.');
      fetchOutcome.success = true; // Technically successful, just skipped
      return; // Return early
    }
    
    console.log(`[SW] Running background sync for wallets:`, currentWallets);
    const startTime = Date.now(); // Use start time for fetch timestamp logic
    fetchOutcome.timestamp = startTime;
    console.log(`[SW Background Debug] Attempting fetchAllPositions at ${new Date(startTime).toISOString()}`);

    // Throttle API calls
    const timeSinceLastFetch = startTime - lastFetchTime;
    const throttleThreshold = MIN_FETCH_INTERVAL - THROTTLE_TOLERANCE;
    console.log(`[SW] Time since last fetch: ${timeSinceLastFetch}ms, Threshold: ${throttleThreshold}ms (Min: ${MIN_FETCH_INTERVAL}ms, Tolerance: ${THROTTLE_TOLERANCE}ms)`);
    if (timeSinceLastFetch < throttleThreshold) {
      console.log(`[SW] Throttling fetch. Will retry on next scheduled interval.`);
      fetchOutcome.success = false; // Throttled, not successful fetch
      return; // Return early if throttled
    }
    
    // Update last fetch time *before* making the API call
    lastFetchTime = startTime;
    console.log(`[SW] Starting API fetch at ${new Date(startTime).toLocaleTimeString()}`);

    // --- Actual Fetch Logic ---
    const db = await initializeDB();
    if (!db) {
      console.error('[SW] Failed to initialize DB for sync.');
      return; // DB failure, don't proceed
    }

    // Fetch and store results directly in the outcome object
    fetchOutcome.results = await Promise.all(
      currentWallets.map(wallet => fetchWalletPnL(wallet))
    );

    const allPositions = fetchOutcome.results
                            .filter(data => data && !data.error && Array.isArray(data.positions))
                            .flatMap(data => data.positions);
                            
    fetchOutcome.positionsFound = allPositions.length;

    if (allPositions.length > 0) {
      console.log(`[SW] Saving snapshot for ${allPositions.length} total positions.`);
      const success = await savePositionSnapshot(db, allPositions);
      if (!success) {
        console.error('[SW] Failed to save combined position snapshot.');
        fetchOutcome.success = false; // Mark as failed if save failed
      } else {
        fetchOutcome.success = true; // Mark as successful
      }
    } else {
      const fetchErrors = fetchOutcome.results.filter(data => data && data.error);
      if (fetchErrors.length > 0) {
          console.warn(`[SW] Fetched data contained errors for ${fetchErrors.length} wallet(s). No valid positions saved.`);
          fetchOutcome.success = false; // Consider fetch with errors as not fully successful
      } else {
          console.log('[SW] No valid positions found across all wallets to save.');
          fetchOutcome.success = true; // Successful fetch, just no data
      }
    }

  } catch (error) {
    console.error('[SW] Error during fetchAllPositions:', error);
    fetchOutcome.success = false; // Mark as failed on general error
  } finally {
      syncInProgress = false;
      console.log(`[SW Background Debug] Completed fetchAllPositions attempt at ${new Date().toISOString()}`);

      // Always notify clients about the attempt completion in finally block
      try {
          const clients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true });
          if (clients.length > 0) {
            clients.forEach(client => {
              try {
                client.postMessage({
                  type: 'NEW_POSITIONS_DATA', 
                  timestamp: fetchOutcome.timestamp, 
                  success: fetchOutcome.success, 
                  results: fetchOutcome.results, 
                  completed: true 
                });
              } catch (err) {
                console.error(`[SW Finally Notify] Failed to notify client ${client.id}:`, err);
              }
            });
          }
      } catch (error) {
        console.error('[SW Finally Notify] Error notifying clients:', error);
      }
  }
};

/**
 * Gatekeeper function to request a sync attempt.
 * Prevents multiple concurrent executions of fetchAllPositions.
 */
const requestSyncAttempt = async () => {
  if (syncInProgress) {
    console.log('[SW Request Sync] Sync already in progress. Request ignored.');
    return;
  }
  console.log('[SW Request Sync] Initiating sync attempt.');
  await fetchAllPositions();
};

/**
 * Handles the FORCE_SYNC message type from the UI.
 * Uses the requestSyncAttempt gatekeeper.
 */
const handleForceSync = async () => {
  console.log('[SW] Received FORCE_SYNC message. Requesting sync attempt.');
  // The actual throttling check is now inside fetchAllPositions,
  // called via the requestSyncAttempt gatekeeper.
  await requestSyncAttempt();
};

/**
 * Starts the periodic background sync timer.
 * Ensures any existing timer is stopped first.
 * Uses the requestSyncAttempt gatekeeper.
 */
const startSyncTimer = () => {
  // If a timer is already running, clear it first
  stopSyncTimer();
  
  // Set flag indicating timer is running
  isTimerRunning = true;
  const now = Date.now();
  const nextSyncTime = new Date(now + syncIntervalId).toLocaleTimeString();
  
  console.log(`[SW Timer Debug] ⏰ Starting background sync timer at ${new Date(now).toLocaleTimeString()}`);
  console.log(`[SW Timer Debug] 📅 Next sync scheduled for: ${nextSyncTime}`);
  console.log(`[SW Timer Debug] ⚙️ Timer config:`, {
    interval: `${syncIntervalId / REFRESH_INTERVALS.SECONDS}s`,
    timerId: now,
    isTimerRunning
  });
  
  // Run immediately first time via the gatekeeper
  console.log('[SW Timer Debug] Requesting initial sync attempt on timer start.');
  requestSyncAttempt(); 
  
  // Create new timer
  syncTimer = setInterval(() => {
    const currentTime = new Date().toISOString();
    console.log(`[SW Timer Debug] 🔄 Timer tick at ${currentTime}`);
    console.log(`[SW Background Debug] Timer tick - initiating sync check via gatekeeper at ${currentTime}`);
    requestSyncAttempt(); // Use gatekeeper for subsequent ticks
  }, syncIntervalId);
};

const stopSyncTimer = () => {
  if (syncTimer) {
    const currentTime = new Date().toLocaleTimeString();
    console.log(`[SW Timer Debug] ⏹️ Stopping background sync timer at ${currentTime}`);
    console.log(`[SW Timer Debug] 📊 Timer final state:`, {
      wasRunning: isTimerRunning,
      interval: `${syncIntervalId / REFRESH_INTERVALS.SECONDS}s`
    });
    
    clearInterval(syncTimer);
    syncTimer = null;
    isTimerRunning = false;
  }
};

// --- Service Worker Event Listeners ---

self.addEventListener('install', (event) => {
  console.log('[SW] Installed');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activated');
  // Claim clients immediately and then proceed with initialization and requests
  event.waitUntil(self.clients.claim().then(() => {
    // After claiming, initialize DB and load initial state directly
    return initializeDB().then(async (db) => { // Get DB instance
      console.log('[SW] DB initialized on activation.');
      if (!db) {
        console.error('[SW Activate] Failed to get DB instance for initial load.');
        return; 
      }

      // Initialize lastFetchTime
      lastFetchTime = Date.now(); 
      console.log(`[SW] Initialized lastFetchTime to ${new Date(lastFetchTime).toISOString()}`);
      
      // Load active wallets directly from IndexedDB
      try {
        const activeWalletsData = await getData(db, STORE_NAMES.WALLETS, 'activeWallets');
        const loadedWallets = activeWalletsData?.value || [];
        currentWallets = Array.isArray(loadedWallets) ? loadedWallets : []; 
      } catch (error) {
        console.error('[SW Activate] Error loading wallets directly from DB:', error);
        currentWallets = []; // Default to empty on error
      }

    });
  }));
});

self.addEventListener('message', (event) => {
  console.log('[SW] Message received:', event.data);
  if (!event.data) return;

  switch (event.data.type) {
    case 'SET_WALLETS':
      currentWallets = event.data.wallets || [];
      console.log('[SW] Updated wallets for sync:', currentWallets);
      break;
    case 'START_SYNC':
      console.log('[SW] Received START_SYNC message.');
      if (currentWallets.length > 0) {
        // Only start if not already running
        if (!isTimerRunning) {
          startSyncTimer();
        } else {
          console.log('[SW] Sync timer already running, ignoring duplicate START_SYNC.');
        }
      } else {
        console.log('[SW] Cannot start sync: No wallets provided yet.');
      }
      break;
    case 'STOP_SYNC':
      console.log('[SW] Received STOP_SYNC message.');
      stopSyncTimer();
      break;
    case 'SET_INTERVAL':
      const newInterval = Number(event.data.interval) * REFRESH_INTERVALS.SECONDS;
      if (!isNaN(newInterval) && newInterval > 0) {
        syncIntervalId = newInterval;
        console.log(`[SW] Sync interval updated to: ${syncIntervalId / REFRESH_INTERVALS.SECONDS}s`);
        if (isTimerRunning) {
          // Restart timer with new interval
          console.log('[SW] Restarting timer with new interval');
          startSyncTimer();
        }
      } else {
        console.warn(`[SW] Received invalid interval: ${event.data.interval}`);
      }
      break;
    case 'FORCE_SYNC':
      handleForceSync();
      break;
    default:
      console.warn('[SW] Received unknown message type:', event.data.type);
  }
});

// Note: fetch listener for caching is omitted as per the plan. 